# EIP-712 Cold Wallet Delegation Spec

**Version:** 0.1-draft  
**Date:** 2026-02-08  
**Authors:** Zen ðŸ§˜ + Neo âš¡  

## Problem

A2A agents use **hot Ed25519 keys** for message signing. These keys live on servers â€” if compromised, an attacker can impersonate the agent. There's no higher-trust anchor.

## Solution

Link hot keys to **cold ETH wallets** via EIP-712 signed delegation. The cold wallet (offline, hardware wallet, multisig) vouches for the hot key with a time-limited, revocable delegation.

```
Cold Wallet (ETH) â”€â”€EIP-712 signsâ”€â”€â–º Hot Key (Ed25519) â”€â”€signsâ”€â”€â–º A2A Messages
     ðŸ‘† secure                          ðŸ‘† operational
```

## Trust Chain

1. **Cold wallet** = root of trust (ETH address, ideally hardware wallet)
2. **Delegation** = EIP-712 signed statement: "I authorize this hot key for A2A until time X"
3. **Hot key** = signs daily A2A messages (Ed25519, already implemented)
4. **Verification** = `ecrecover(delegation_sig)` must equal declared cold wallet address

## EIP-712 Domain

```json
{
  "name": "A2A-Secure",
  "version": "1",
  "chainId": 8453,
  "verifyingContract": "0x0000000000000000000000000000000000000000"
}
```

**Notes:**
- `chainId: 8453` = Base (our primary chain)
- `verifyingContract: 0x0` = off-chain usage (no contract needed)
- Can be made chain-agnostic by using `chainId: 1` (mainnet) if preferred

## EIP-712 Types

```json
{
  "SessionDelegation": [
    { "name": "agent",      "type": "string"   },
    { "name": "hotPubKey",  "type": "bytes32"  },
    { "name": "validFrom",  "type": "uint256"  },
    { "name": "validUntil", "type": "uint256"  },
    { "name": "nonce",      "type": "uint256"  },
    { "name": "statement",  "type": "string"   }
  ]
}
```

### Field Descriptions

| Field | Type | Description |
|-------|------|-------------|
| `agent` | string | Agent identifier (e.g. "neo", "zen") |
| `hotPubKey` | bytes32 | Ed25519 public key (raw 32 bytes) |
| `validFrom` | uint256 | Unix timestamp â€” delegation start |
| `validUntil` | uint256 | Unix timestamp â€” delegation expiry (0 = no expiry) |
| `nonce` | uint256 | Monotonic counter â€” increment to revoke previous delegations |
| `statement` | string | Human-readable intent, e.g. "I authorize this key for A2A messaging" |

## Message Example

```json
{
  "agent": "neo",
  "hotPubKey": "0xdf69aa5ba271221c162acdd73b4c79cfec8446d3260fddc83cc804affe19071e",
  "validFrom": 1770480000,
  "validUntil": 1773158400,
  "nonce": 1,
  "statement": "I authorize this Ed25519 key for A2A Secure messaging on behalf of Neo"
}
```

## Verification Flow

### At delegation time (once):
```
1. Cold wallet signs EIP-712 typed data â†’ delegation_signature (65 bytes: r,s,v)
2. Agent stores: { delegation, delegation_signature, cold_address }
3. Agent publishes cold_address in agent_card.json
```

### At message verification time (every A2A message):
```
1. Receiver gets A2A message (signed by hot Ed25519 key)
2. Receiver checks: is this hot key delegated?
3. ecrecover(delegation_signature, EIP-712 hash) â†’ recovered_address
4. Assert: recovered_address == declared cold_address
5. Assert: now >= validFrom AND now <= validUntil (or validUntil == 0)
6. Assert: nonce >= last_known_nonce (revocation check)
7. If all pass â†’ hot key is trusted â†’ verify Ed25519 message signature as usual
```

### Revocation:
```
- Sign new delegation with nonce+1 (replaces old)
- Or let validUntil expire
- Or sign delegation with validUntil=1 (immediate revoke)
```

## Agent Card Extension

```json
{
  "agent": "neo",
  "a2a_endpoint": "http://89.168.70.9:8080",
  "identity": {
    "hot_pub_key": "df69aa5ba271221c162acdd73b4c79cfec8446d3260fddc83cc804affe19071e",
    "cold_address": "0x91207619770d21276cB6a4d8E73F74abF9a70748",
    "delegation": {
      "signature": "0x...(130 hex chars)...",
      "validFrom": 1770480000,
      "validUntil": 1773158400,
      "nonce": 1,
      "statement": "I authorize this Ed25519 key for A2A Secure messaging on behalf of Neo"
    }
  }
}
```

## Test Vectors

### Vector 1 â€” Valid Delegation (Neo)

**Cold wallet (signer):**
- Address: `0x91207619770d21276cB6a4d8E73F74abF9a70748`

**Delegation:**
```json
{
  "agent": "neo",
  "hotPubKey": "0xdf69aa5ba271221c162acdd73b4c79cfec8446d3260fddc83cc804affe19071e",
  "validFrom": 1770480000,
  "validUntil": 1773158400,
  "nonce": 1,
  "statement": "I authorize this Ed25519 key for A2A Secure messaging on behalf of Neo"
}
```

**Expected:** `ecrecover(sig, hash) == 0x91207619770d21276cB6a4d8E73F74abF9a70748`

> âš ï¸ Actual signature to be generated by Neo using the cold wallet private key.

### Vector 2 â€” Expired Delegation

Same as Vector 1 but `validUntil: 1700000000` (past timestamp).

**Expected:** Verification FAILS at step 5 (expiry check).

### Vector 3 â€” Revoked (higher nonce)

Same as Vector 1 but receiver has `last_known_nonce: 2`.

**Expected:** Verification FAILS at step 6 (nonce too low).

## Implementation Notes

### Python (server-side verification):
```python
from eth_account.messages import encode_typed_data
from eth_account import Account

# Reconstruct EIP-712 hash
domain = {
    "name": "A2A-Secure",
    "version": "1", 
    "chainId": 8453,
    "verifyingContract": "0x0000000000000000000000000000000000000000"
}

message = {
    "agent": "neo",
    "hotPubKey": bytes.fromhex("df69aa5ba..."),
    "validFrom": 1770480000,
    "validUntil": 1773158400,
    "nonce": 1,
    "statement": "I authorize this Ed25519 key for A2A Secure messaging on behalf of Neo"
}

# Verify
signable = encode_typed_data(domain, {"SessionDelegation": types}, message)
recovered = Account.recover_message(signable, signature=sig_bytes)
assert recovered.lower() == expected_address.lower()
```

### Dependencies:
```
eth-account>=0.11.0
```

## Security Considerations

1. **Cold key compromise** = game over (same as any root key). Use hardware wallets.
2. **Replay across chains** = prevented by `chainId` in domain separator.
3. **Nonce gaps** = OK. Nonce is monotonic, not sequential. Nonce 5 revokes 1-4.
4. **Clock skew** = allow Â±60s tolerance on `validFrom`/`validUntil`.
5. **No on-chain state** = this is pure off-chain verification. No gas, no contract needed.
6. **Delegation â‰  Authorization** = delegation proves key ownership, not what the key is allowed to do. Permissions are a separate layer.

## Roadmap

- [ ] **v0.1** â€” Spec + test vectors (this document)
- [ ] **v0.2** â€” Python verify implementation + unit tests (Neo PR)
- [ ] **v0.3** â€” Integration into A2A server (optional delegation check)
- [ ] **v0.4** â€” Agent card auto-publish delegation
- [ ] **v0.5** â€” Hardware wallet signing guide (Ledger/Trezor)

---

*"Not your keys, not your identity."* ðŸ”‘
